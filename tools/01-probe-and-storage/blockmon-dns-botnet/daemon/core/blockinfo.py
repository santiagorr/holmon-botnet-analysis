from block import BlockInfo, GateInfo, VariableInfo, IntegerRange

block_infos = {"L4Demux": BlockInfo("L4Demux", "direct, indirect", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_tcp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_udp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_unknown", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [], "Takes Packet messages and demultiplexes them across three possible output    gates depending on their transport protocol: TCP packets are forwarded    through the out_tcp gate, UDP packets through out_udp and any other packet    through out_unknown.", "Demultiplexes packets based on their transport protocol", False), "AppendTag": BlockInfo("AppendTag", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element tag\n        {\n            attribute type {'long'|'double'|'int'}\n            attribute id {text}\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <tag type='double' name = 'random_tag'/>\n      </params>\n    </paramsexample>\n", [], "This is a test-only block that appends random-value tags to Packet messages.        The block can append three different tag type, which can be configured at block configuration time.        The content of the tag to be written is a 64-bit random value which is computed on a per-packet base.", "Appends tags with random values to the packet message.", False), "PcapSource": BlockInfo("PcapSource", "async", [GateInfo("output", "source_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source {\n         attribute type {'live' | 'trace'}\n         attribute name {text}\n         attribute snaplen {int}\n       }\n       element bpf_filter {text}?\n       element advance_time_at_eof {\n      	  attribute us {in}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <source type='live' name='eth0' snaplen='1514' />\n         or\n         <source type='trace' name='trace.pcap' />\n 		  <advance_time_at_eof us='360000000'/>\n       <bpf_filter expression=' ' />\n      </params>\n    </paramsexample>\n", [], "Captures traffic from a local interface or pcap trace file and outputs      packets using a Packet message. If the source parameter is set to live,      the name parameter should be an interface's name (e.g., eth0). If the      source type is set to trace, then the name should be the full path to a      pcap trace file (e.g., /tmp/mytrace.pcap). Use the bfp paramter to filter      traffic using BFP syntax.      The 'advance_time_at_eof' parameter is used only if a pcap trace file is      read and the PACKET clock is used. In this case, and if this parameter is      specified, the PACKET clock will be advanced by the specified amount of      microseconds after the end of the pcap file is reached. This allows potential      timers to fire even though the time is no longer advancing after the end of the      file.", "Captures traffic from a local interface or pcap trace file", True), "IPDumbAnonymizer": BlockInfo("IPDumbAnonymizer", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element anon {\n         attribute src {'True' | 'False'}?\n         attribute dst {'True' | 'False'}?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <anon src='True'/>\n      </params>\n    </paramsexample>\n", [], "This block can anonymize the source address and/or the destination    address of an IP packet (this can be set as config param). Notice that, as    this operation needs to modify the packet contents, the message is cloned    before being modified.", "Anonymizes ip addresses in a Packet message", False), "ComboPktSource": BlockInfo("ComboPktSource", "indirect", [GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element design {\n           attribute filename {xsd:string}\n       }\n       element channels {\n           attribute rx_mask {xsd:integer}\n       }\n       element interfaces {\n           attribute enable {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params> \n       <design filename='/path/to/firmware.mcs'/>\n       <channels rx_mask='255'/>\n       <interfaces enable='1'/>\n   </params>\n    </paramsexample>\n", [VariableInfo("ComboPktSource", "pktcnt", "integer", "read"), VariableInfo("ComboPktSource", "pktagg", "integer", "write")], "This block is a wrapper to the SZE2 API available as a part of NetCOPE FPGA framework:     http://www.invea-tech.com/products-and-services/netcope-fpga-platform     A block of this kind can be associated to one or more hardware queues    available on the FPGA acceleration card. Subscribed queues are specified    as a configuration parameter in a mask where each bit corresponds to a single queue.    If no value is provided default value is used. This block supports batch    message allocation in order to optimize performance", "Captures traffic from a local interface by means of the SZE2 API as part of NetCOPE", True), "IPFIXExporter": BlockInfo("IPFIXExporter", "direct, indirect", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element domain {xsd:integer}?,\n        element export {\n            attribute transport {'udp'|'tcp'|'sctp'},\n            attribute host  {text},\n            attribute port  {xsd:integer}?\n            } |\n        element file {\n            attribute name {text}\n        }\n        element datatype {\n            attribute name {text}\n        }\n        element fastflush?\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <domain id='1'/>\n        <export host='ipfix-collector.example.net' port='4739' transport='tcp'/>\n        <datatype name='ipv4flow'/>\n        or\n        <file name='foo.ipfix'/>\n        <datatype name='ipv4flow'/>\n      </params>\n    </paramsexample>\n", [], "Receives a message and exports it via an IPFIX transport session or into   an IPFIX file. This block can handle any message class for which there   is a registered record type.    Note that this block can handle any message class for which an associated   datatype entry exists in the configuration. Messages sent to this block    for which no datatype entry is available are ignored but logged.", "Exports Blockmon messages via IPFIX", True), "Null": BlockInfo("Null", "both", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Discards every message it receives.", "Discards every message it receives.", False), "RRDemux": BlockInfo("RRDemux", "direct", [GateInfo("input", "input", "Msg", IntegerRange(0, 0)), GateInfo("output", "output1", "Msg", IntegerRange(0, 0)), GateInfo("output", "output2", "Msg", IntegerRange(0, 0)), GateInfo("output", "outputN", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element gates {\n         attribute number {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <gates number='5' />\n      </params>\n    </paramsexample>\n", [], "Receives messages and sends them through a configured number      of output gates in a round-robin fashion. There can be any number of      output gates, each named outputX with X going from 1 to the configured      number of gates.", "Sends messages out through its gates in a round-robin fashion", False), "PFQSource": BlockInfo("PFQSource", "indirect", [GateInfo("output", "source_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element queues {\n           attribute device {text}\n           attribute caplen {xsd:integer, default=1514}\n           attribute offset {xsd:integer, default=0}\n           attribute slots {xsd:integer, default=131072}\n           element queue {\n                attribute number {xsd:integer}\n                }\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params>                                                                                                                                 \n       <queues device='eth3' caplen='1514' offset='0' slots='131072'>\n           <queue number='0'/>\n       </queues> \n   </params>\n    </paramsexample>\n", [], "Wrapper to the PFQ capturing engine:     http://netgroup.iet.unipi.it/software/pfq/     A block of this kind can be associated to a network interface or to a    subset of its associated hardware queues. This is specified as a    configuration parameter: a set of queues for the interface can be    specified, if this is empty the block captures all of the packets on the interface.    This block supports batch message allocation in order to optimize performance", "Captures traffic from a local interface by means of the PFQ capturing engine", True), "FlowMeter": BlockInfo("FlowMeter", "indirect", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       attribute store_packets {xsd:boolean}?\n       element idle_timeout{\n            attribute ms {xsd:integer}\n            }?\n       element idle_timeout{\n            attribute ms {xsd:integer}\n            }?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params store_packets='true'>\n           <active_timeout ms='500'/>\n           <idle_timeout ms='100'/>\n      </params>\n    </paramsexample>\n", [], "Receives packet messages and keeps a table of per-flow statistics, and, depending on the configuration, also the packets making up that flow.        A circular queue is used to keep track of the last time a flow has been checked for         expiration.         Two timeout values are used. The first one is the idle timeout (default value is 500 ms): whenever a flow record has not been        receiving a packet for more than such time interval, the flow is considered as expired, its associated        record is sent out and its table entry erased .      The second one, the active timeout (default value is 100 ms), is activated when a flow has been active for longer than the corresponding time        interval. When such timeout expires, a record about the flow is sent out and the counters in the corresponding table entry        are reset.         Notice that, while the idle timeout is checked by using a Blockmon timer mechanism, the indirect timeout is checked upon        arrival of a new packet belonging to the flow.", "Receives packet messages and keeps a table of per-flow statistics, and, depending on the configuration, also the packets making up that flow.", False), "SerExporter": BlockInfo("SerExporter", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element export {\n            attribute host {text},\n            attribute port {xsd:integer}?\n            }\n        }\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <export host='131.114.54.11' port='113'/>\n      </params>\n    </paramsexample>\n", [], "Receives a message and exports it through a TCP session.    For a message to be exported it should do what?", "Exports Blockmon internal messages over TCP session", True), "FlowPrinter": BlockInfo("FlowPrinter", "direct, indirect", [GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Flow message and prints its associated information (as returned    by the methods in the Flow class)", "Prints meta-information regarding a flow", False), "IDMEFExporter": BlockInfo("IDMEFExporter", "direct", [GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element export {\n            attribute host  {text},\n            attribute port {xsd:integer}\n            } |\n        element file {\n            attribute name {text}\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <export host='192.168.0.3' port='1234' />\n      </params>\n    </paramsexample>\n", [], "Receives alert messages and exports them as IDMEF.      Export can ben done to a file or to a distant machine through TCP.", "Receives alert messages and exports them as IDMEF", False), "SynthSource": BlockInfo("SynthSource", "indirect", [GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element rate {\n         attribute pps {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <rate pps='10000'/>\n      </params>\n    </paramsexample>\n", [], "Generates TCP/IP packets with random IP addresses and ports.    The number of packets per second can be tuned as a configuration parameter.", "Generates synthetic traffic with random addresses and ports", True), "FlowFilter": BlockInfo("FlowFilter", "direct, indirect", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n            element ip_src{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_dst{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element l4_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element src_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element dst_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <ip_src address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='discard'/>\n            </ip_src>\n \n            <ip_dst address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='accept'/>\n             </ip_dst>\n \n             <l4_protocol number='6'>\n                <filter_mode behavior='accept'/>\n            </l4_protocol>\n \n            <src_port number='80'>\n                <filter_mode behavior='accept'/>\n            </src_port>\n \n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on conditions specified over the 5-tuple", False), "IPFIXSource": BlockInfo("IPFIXSource", "async", [GateInfo("output", "source_out", "Any", IntegerRange(0, 0))], "   <paramsschema>\n     element params {\n        element collect {\n            attribute transport {'udp'|'tcp'|'sctp'},\n            attribute port      {xsd:integer}?\n            } |\n        element file {\n            attribute name {text}\n        }\n        element datatype {\n            attribute name {text}\n        }\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <collect port='4739' transport='tcp'/>\n        <datatype name='ipv4flow'/>\n        or\n        <file name='foo.ipfix'/>\n        <datatype name='ipv4flow'/>\n      </params>\n    </paramsexample>\n", [], "Reads records from an IPFIX transport session and outputs messages       according to the datatypes registered with the source block. May      send out Messages of any type, depending on the data received from       the remote IPFIX device and the the registered data types.", "Receives messages from an IPFIX exporter", True), "ComboUHSource": BlockInfo("ComboUHSource", "indirect", [GateInfo("output", "out_pkt", "UHPacket", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element design {\n           attribute filename {xsd:string}\n       }\n       element channels {\n           attribute rx_mask {xsd:integer}\n       }\n       element interfaces {\n           attribute enable {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params> \n       <design filename='/path/to/firmware.mcs'/>\n       <channels rx_mask='255'/>\n       <interfaces enable='1'/>\n   </params>\n    </paramsexample>\n", [VariableInfo("ComboUHSource", "pktcnt", "integer", "read"), VariableInfo("ComboUHSource", "pktagg", "integer", "write")], "This block is a wrapper to the SZE2 API available as a part of NetCOPE FPGA framework:     http://www.invea-tech.com/products-and-services/netcope-fpga-platform     A block of this kind can be associated to one or more hardware queues    available on the FPGA acceleration card. Subscribed queues are specified    as a configuration parameter in a mask where each bit corresponds to a single queue.    If no value is provided default value is used. This block supports batch    message allocation in order to optimize performance", "Captures traffic from a local interface by means of the SZE2 API as part of NetCOPE", True), "PeriodFlowMeter": BlockInfo("PeriodFlowMeter", "indirect", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element timeout{\n            attribute ms {xsd:integer}\n            }?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n           <timeout ms='500'/>\n      </params>\n    </paramsexample>\n", [], "Receives packet messages and keeps a table of per-flow statistics.        Upon expiration of a timer (default is 500 ms), the whole table is flushed: a Flow message for        every table entry is sent out and the whole state of the table is erased.", "Receives packet messages and keeps a table of per-flow    statistics, exporting them periodically", False), "TopNFlowSelector": BlockInfo("TopNFlowSelector", "both", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element top_flows{\n        attribute number {xsd:integer}\n        }?\n        element period{\n        attribute msecs {xsd:integer}\n        }?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n             <top_flows number='10'/>\n             <period msecs='4000'/>\n      </params>\n    </paramsexample>\n", [], "Receives Flow messages and keeps a list of the N messages with the highest number of packets         Upon expiration of a timer, it sends all of them out of its out gate.         The number N of messages to be selected, along with the flush period, are optional configuration parameters.         Default values are 10 messages and 100ms respectively", "Selects the flows with the highest number of packets", False), "FlowCounter": BlockInfo("FlowCounter", "direct", [GateInfo("input", "in_pkt", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("FlowCounter", "pktcnt", "integer", "read"), VariableInfo("FlowCounter", "bytecnt", "integer", "read"), VariableInfo("FlowCounter", "flowcnt", "integer", "read"), VariableInfo("FlowCounter", "byterate", "integer", "read"), VariableInfo("FlowCounter", "pktrate", "integer", "read"), VariableInfo("FlowCounter", "flowrate", "integer", "read"), VariableInfo("FlowCounter", "reset", "write 1 to reset counts", "write")], "Keeps flow, packet and byte counts of Flows going through it.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps flow packet and byte counts of traffic going through it.", False), "ProtocolFilter": BlockInfo("ProtocolFilter", "direct, indirect", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n           element protocol{\n            attribute type {xsd:integer}\n            }?\n           }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <!-- select IP packets -->\n            <protocol type='0800' />\n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on the value of the ethernet type field", False), "CDFGenerator": BlockInfo("CDFGenerator", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element cdf_build {\n                attribute interval {xsd:integer}\n            }\n       element cdf_param{\n            attribute min {xsd:integer}\n            attribute max {xsd:integer}\n            attribute bin {xsd:integer}\n            }\n       element diff_priv{\n            attribute epsilon {xsd:float}\n            }\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n             <build_cdf interval='2000'/> #millisecond\n             <cdf_param min='0' max='1500' bin='150'/>\n             <diff_priv epsilon='0.8'/> #if -1 do not add noise\n        </params>\n    </paramsexample>\n", [], "Implements a block that prints the Cumulative Distribution Function        (CDF) of the packet size every interval, adding a noise depending on        the epsilon value. Configuration parameters allow to tune the        endpoints of the CDF, the bin width and to add noise.", "Prints the CDF of packet sizes for a given interval", False), "PacketCounter": BlockInfo("PacketCounter", "direct, indirect", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("PacketCounter", "pktcnt", "integer", "read"), VariableInfo("PacketCounter", "bytecnt", "integer", "read"), VariableInfo("PacketCounter", "byterate", "integer", "read"), VariableInfo("PacketCounter", "pktrate", "integer", "read"), VariableInfo("PacketCounter", "reset", "write 1 to reset packet and byte counts", "write")], "Keeps packet and byte counts of traffic going through it and logs,      every 0.5 seconds, the packet rate.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps packet and byte counts of traffic going through it.", False), "PacketCounter": BlockInfo("PacketCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("PacketCounter", "pktcnt", "integer", "read"), VariableInfo("PacketCounter", "bytecnt", "integer", "read"), VariableInfo("PacketCounter", "byterate", "integer", "read"), VariableInfo("PacketCounter", "pktrate", "integer", "read"), VariableInfo("PacketCounter", "reset", "write 1 to reset packet and byte counts", "write")], "Keeps packet and byte counts of traffic going through it and logs,      every 0.5 seconds, the packet rate.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps packet and byte counts of traffic going through it.", False), "PacketFilter": BlockInfo("PacketFilter", "direct, indirect", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n           element l3_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_src{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_dst{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element l4_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element src_port{\n            element number{\n                attribute value = {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element dst_port{\n            element number{\n                attribute value = {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <l3_protocol number='2048'>\n                <filter_mode behavior='accept'/>\n            </l3_protocol>\n \n            <ip_src address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='discard'/>\n            </ip_src>\n \n            <ip_dst address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='accept'/>\n             </ip_dst>\n \n             <l4_protocol number='6'>\n                <filter_mode behavior='accept'/>\n            </l4_protocol>\n \n            <src_port number='80'>\n                <number value='80'/>\n                <number value='110'/>\n                <filter_mode behavior='accept'/>\n            </src_port>\n \n      </params>\n    </paramsexample>\n", [], "Selects packets based on a set of given conditions. Selected packets are  sent to the block's output gate, non-selected ones are dropped. A packet  is selected if it matches all of the given conditions, and each of the  conditions can be negated. Logically the selection resolves to                                                                                               select = [not]cond1=val AND [not]cond2=val AND [not]cond3=val ...                                                                                                                          where [not] means that the negation is optional. The conditions can be of                     the following kind:                                                                                                                                                                         l3_protocol                                                                                   ip_src                                                                                        ip_dst                                                                                        l4_protocol                                                                                   src_port                                                                                      dst_port                                                                                                                                                                                    Please refer to the schema and examples below to see how to specify                           selection filters. Note that the negation (i.e., 'not') is done via the                       'behavior' parameter, which can be set to 'accept' or 'discard' = negate.                    Default is 'accept'.", "Selects packets based on conditions specified over the 5-tuple", False), "Null": BlockInfo("Null", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Discards every message it receives.", "Discards every message it receives.", False), "PacketPrinter": BlockInfo("PacketPrinter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Packet message and prints its associated information    (as returned by the methods in the Packet class)", "Prints meta-information regarding a packet", False), "SyncTag": BlockInfo("SyncTag", "both", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element tags\n        {\n            element tag {\n            attribute name {text}\n            }\n         }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <tag name = 'tag1'/>\n        <tag name = 'tag2'/>\n        </tags>\n        </params>\n    </paramsexample>\n", [], "Test block that waits for a message to have a set of tags set before forwarding it.    The block is configured with a set of tag to wait for: if all of them are written (the value is not read)    it forwards the message to the next block, otherwise it discards it.    If the same message is going through different parallel processing chains, is will reach the synchronization    block several times and eventually all of its tags will be written.", "Wait for a message to have a set of tags written", False)}
