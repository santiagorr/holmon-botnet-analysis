/* Copyright (c) 2011, NEC Europe Ltd, Consorzio Nazionale 
 * Interuniversitario per le Telecomunicazioni, Institut 
 * Telecom/Telecom Bretagne, ETH Zürich, INVEA-TECH a.s. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of NEC Europe Ltd, Consorzio Nazionale 
 *      Interuniversitario per le Telecomunicazioni, Institut Telecom/Telecom 
 *      Bretagne, ETH Zürich, INVEA-TECH a.s. nor the names of its contributors 
 *      may be used to endorse or promote products derived from this software 
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT 
 * HOLDERBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
 */

#ifndef _CORE_MARSHFACTORY_HPP_
#define _CORE_MARSHFACTORY_HPP_

#include <map>
#include <memory>
#include <netinet/in.h>
#include <Msg.hpp>
#include <Buffer.hpp>
#include <ClassId.hpp>

namespace blockmon
{

    class BaseMarshall
    {
    public:
        BaseMarshall()
        {}

        virtual ~BaseMarshall()
        {}

        virtual int marshall(const Msg&, mutable_buffer<char>) const = 0;
        virtual std::shared_ptr<const Msg> unmarshall(const_buffer<char>) const =0;
    };

    /*
     * small header for marshalling:(precedes the actual buffer)
     *8 bytes:
     *int code 
     *unsigned int length
     * */

    class MarshallFactory
    {
        std::map<int, std::shared_ptr<BaseMarshall>> m_map;

        MarshallFactory(): m_map()
        {}

        MarshallFactory(const MarshallFactory&) = delete;
        MarshallFactory& operator=(const MarshallFactory&) = delete;

    public:
        static const int HEAD_SIZE = 2*sizeof(unsigned int);

        static MarshallFactory& 
        instance()
        {
            static MarshallFactory the_factory;
            return the_factory;
        }

        int 
        marshall(const Msg& inm, mutable_buffer<char> inb)
        {
            int newlen=inb.len()-HEAD_SIZE;
            if(newlen<=0)
                throw std::runtime_error("marshalling:: provided buffer is too small");

            auto it = m_map.find(inm.type());
            if(it==m_map.end())
                throw std::runtime_error("marshalling:: message type not supported");

            *(reinterpret_cast<int*>(inb.addr())) = htonl(inm.type());

            int m_len = it->second->marshall(inm,mutable_buffer<char>(inb.addr()+HEAD_SIZE,newlen));

            *(reinterpret_cast<unsigned int*>(inb.addr()+sizeof(int))) = htonl(m_len);
            return m_len+HEAD_SIZE;
        }

        std::shared_ptr<const Msg> 
        unmarshall(const_buffer<char> inb)
        {
            std::map<int, std::shared_ptr<BaseMarshall> >::iterator it;
            int type=ntohl(*reinterpret_cast<const int*> (inb.addr()));	
            unsigned int len=ntohl(*reinterpret_cast<const unsigned int*> (inb.addr()+sizeof(int)));

            it=m_map.find(type);
            if(it==m_map.end())
                throw std::runtime_error("marshalling:: message type not supported");
            return it->second->unmarshall(const_buffer<char>(inb.addr()+HEAD_SIZE,len));
        }

        void f_register(int msg_code, std::shared_ptr<BaseMarshall>&& inb)
        {
            if(m_map.find(msg_code)!=m_map.end())
                return;
            m_map[msg_code]=std::move(inb);
        }
    };

    //TODO:: message with hard-coded message code (not generated by type_to_id) are not yet compatible with this factory: a type-traits mechanism is needed

    template <typename M, typename T>
    class marshall_factory_register
    {
    public:
        marshall_factory_register()
        {
            MarshallFactory::instance().f_register(type_to_id<T>::id(), typename std::shared_ptr<BaseMarshall>(static_cast<BaseMarshall*>(new M)));
        }	
    };


#define REGISTER_MARSHALLING_MODULE(module,type)\
    namespace\
    {\
        marshall_factory_register<module,type> the_local_factory_register; \
    } 
}

#endif // _CORE_MARSHFACTORY_HPP_
