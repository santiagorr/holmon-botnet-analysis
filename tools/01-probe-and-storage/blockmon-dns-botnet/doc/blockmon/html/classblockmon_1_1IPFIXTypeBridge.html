<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>blockmon: blockmon::IPFIXTypeBridge Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">blockmon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceblockmon.html">blockmon</a></li><li class="navelem"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html">IPFIXTypeBridge</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classblockmon_1_1IPFIXTypeBridge-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blockmon::IPFIXTypeBridge Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="IPFIXTypeBridge_8hpp_source.html">IPFIXTypeBridge.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for blockmon::IPFIXTypeBridge:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classblockmon_1_1IPFIXTypeBridge.png" usemap="#blockmon::IPFIXTypeBridge_map" alt=""/>
  <map id="blockmon::IPFIXTypeBridge_map" name="blockmon::IPFIXTypeBridge_map">
<area href="classIPFIX_1_1RecordReceiver.html" alt="IPFIX::RecordReceiver" shape="rect" coords="218,56,426,80"/>
<area href="classIPFIX_1_1SetReceiver.html" alt="IPFIX::SetReceiver" shape="rect" coords="218,0,426,24"/>
<area href="classblockmon_1_1IPFIXFlowBridge.html" alt="blockmon::IPFIXFlowBridge" shape="rect" coords="0,168,208,192"/>
<area href="classblockmon_1_1IPFIXObservationBridge.html" alt="blockmon::IPFIXObservationBridge" shape="rect" coords="218,168,426,192"/>
<area href="classblockmon_1_1SCDemoFlowBridge.html" alt="blockmon::SCDemoFlowBridge" shape="rect" coords="436,168,644,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a59dbb6e00423060596aec3b11ec3333b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a59dbb6e00423060596aec3b11ec3333b">prepareExporter</a> (<a class="el" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a> &amp;e)=0</td></tr>
<tr class="memitem:af54aff08f9c866d41c0d628a2c8ea377"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#af54aff08f9c866d41c0d628a2c8ea377">canExport</a> (std::shared_ptr&lt; const <a class="el" href="classblockmon_1_1Msg.html">Msg</a> &gt; &amp;m)=0</td></tr>
<tr class="memitem:a4bebc40d6ac5092eed5febe348bb5515"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a4bebc40d6ac5092eed5febe348bb5515">exportMsg</a> (std::shared_ptr&lt; const <a class="el" href="classblockmon_1_1Msg.html">Msg</a> &gt; &amp;m, <a class="el" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a> &amp;e)=0</td></tr>
<tr class="memitem:a9da419480cc22135a46b0df3eea7d1b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a9da419480cc22135a46b0df3eea7d1b8">prepareCollector</a> (<a class="el" href="classIPFIX_1_1Collector.html">IPFIX::Collector</a> &amp;c, <a class="el" href="classblockmon_1_1OutGate.html">OutGate</a> &amp;g)=0</td></tr>
<tr class="memitem:ace3a14ecf9d038012ce312882f88301e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#ace3a14ecf9d038012ce312882f88301e">typeName</a> () const </td></tr>
<tr class="inherit_header pub_methods_classIPFIX_1_1RecordReceiver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIPFIX_1_1RecordReceiver')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classIPFIX_1_1RecordReceiver.html">IPFIX::RecordReceiver</a></td></tr>
<tr class="memitem:ac32cd078ef21e546338d6892010d2b27 inherit pub_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#ac32cd078ef21e546338d6892010d2b27">receiveSet</a> (const <a class="el" href="classIPFIX_1_1Collector.html">Collector</a> *collector, <a class="el" href="classIPFIX_1_1Transcoder.html">Transcoder</a> &amp;setxc, const <a class="el" href="classIPFIX_1_1WireTemplate.html">WireTemplate</a> *wt)</td></tr>
<tr class="memitem:af6b150a289a9340be22a94936d5e5446 inherit pub_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6b150a289a9340be22a94936d5e5446"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>receiveRecord</b> ()=0</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adf71bf939c17f5cceabf818d9b098fb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf71bf939c17f5cceabf818d9b098fb9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IPFIXTypeBridge</b> (const std::string &amp;type_name)</td></tr>
<tr class="memitem:a61990c7ac71513219375f894c5dd13aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61990c7ac71513219375f894c5dd13aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setGate</b> (<a class="el" href="classblockmon_1_1OutGate.html">OutGate</a> &amp;g)</td></tr>
<tr class="memitem:aaf7f770fb16738bd19c4b5d848cb492d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf7f770fb16738bd19c4b5d848cb492d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sendMsg</b> (std::shared_ptr&lt; const <a class="el" href="classblockmon_1_1Msg.html">Msg</a> &gt; &amp;&amp;m) const </td></tr>
<tr class="memitem:a955cfbd55b9184ebe83a67c58cadab7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a955cfbd55b9184ebe83a67c58cadab7d">declareIEVec</a> (const char *spec1,...)</td></tr>
<tr class="memitem:aeb083d32c7747a3f69ab593e3f23857e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#aeb083d32c7747a3f69ab593e3f23857e">declareIEVec</a> (std::vector&lt; const <a class="el" href="classIPFIX_1_1InfoElement.html">IPFIX::InfoElement</a> * &gt; &amp;v, const char *spec1,...)</td></tr>
<tr class="memitem:a9778a95677eb46271dd1a5acf5095c4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a9778a95677eb46271dd1a5acf5095c4e">defaultPrepareExporter</a> (<a class="el" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a> &amp;e)</td></tr>
<tr class="memitem:a6039d979ceae39a3342c6172df220d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a6039d979ceae39a3342c6172df220d5a">defaultPrepareCollector</a> (<a class="el" href="classIPFIX_1_1Collector.html">IPFIX::Collector</a> &amp;c, <a class="el" href="classblockmon_1_1OutGate.html">OutGate</a> &amp;g)</td></tr>
<tr class="memitem:acf3aeb67e51ab3f63cc7b23d6106860a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#acf3aeb67e51ab3f63cc7b23d6106860a">defaultPrepareCollector</a> (<a class="el" href="classIPFIX_1_1Collector.html">IPFIX::Collector</a> &amp;c, <a class="el" href="classblockmon_1_1OutGate.html">OutGate</a> &amp;g, std::vector&lt; int &gt; match_indices)</td></tr>
<tr class="inherit_header pro_methods_classIPFIX_1_1RecordReceiver"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classIPFIX_1_1RecordReceiver')"><img src="closed.png" alt="-"/>&nbsp;Protected Member Functions inherited from <a class="el" href="classIPFIX_1_1RecordReceiver.html">IPFIX::RecordReceiver</a></td></tr>
<tr class="memitem:ad105665c0b3dc3601252f25cdf5b058e inherit pro_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#ad105665c0b3dc3601252f25cdf5b058e">getPointer</a> (const <a class="el" href="classIPFIX_1_1InfoElement.html">InfoElement</a> *ie, size_t &amp;len)</td></tr>
<tr class="memitem:af94751648789be240faef16839b33d92 inherit pro_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#af94751648789be240faef16839b33d92">getValue</a> (const <a class="el" href="classIPFIX_1_1InfoElement.html">InfoElement</a> *ie, void *vp, size_t len)</td></tr>
<tr class="memitem:a3cb1ba2a251cc102526229df04d8e58f inherit pro_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#a3cb1ba2a251cc102526229df04d8e58f">getValue</a> (const <a class="el" href="classIPFIX_1_1InfoElement.html">InfoElement</a> *ie, uint64_t &amp;val)</td></tr>
<tr class="memitem:a1b25a2d8020791195d6a670a3e227ca3 inherit pro_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#a1b25a2d8020791195d6a670a3e227ca3">getValue</a> (const <a class="el" href="classIPFIX_1_1InfoElement.html">InfoElement</a> *ie, uint32_t &amp;val)</td></tr>
<tr class="memitem:a7cf4c7cb1bb084f4ef9d982f4ccc7d55 inherit pro_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#a7cf4c7cb1bb084f4ef9d982f4ccc7d55">getValue</a> (const <a class="el" href="classIPFIX_1_1InfoElement.html">InfoElement</a> *ie, uint16_t &amp;val)</td></tr>
<tr class="memitem:a962737c9713da4528d73448c21d8f002 inherit pro_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#a962737c9713da4528d73448c21d8f002">getValue</a> (const <a class="el" href="classIPFIX_1_1InfoElement.html">InfoElement</a> *ie, uint8_t &amp;val)</td></tr>
<tr class="memitem:aaae2a67a2fe658e5fd1ee8bd21fe8019 inherit pro_methods_classIPFIX_1_1RecordReceiver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPFIX_1_1RecordReceiver.html#aaae2a67a2fe658e5fd1ee8bd21fe8019">getValue</a> (const <a class="el" href="classIPFIX_1_1InfoElement.html">InfoElement</a> *ie, std::string &amp;val)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9c502e8ac0152d28192ff95a8733c61f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c502e8ac0152d28192ff95a8733c61f"></a>
std::vector&lt; const <br class="typebreak"/>
<a class="el" href="classIPFIX_1_1InfoElement.html">IPFIX::InfoElement</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_ievec</b></td></tr>
<tr class="memitem:aba099055e24b9fabd4dc5eb07c0a5f99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba099055e24b9fabd4dc5eb07c0a5f99"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_tid</b></td></tr>
<tr class="memitem:a81d5b6b64df2ae42708aebb3943688e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81d5b6b64df2ae42708aebb3943688e9"></a>
<a class="el" href="classIPFIX_1_1MatchTemplate.html">IPFIX::MatchTemplate</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_mtmpl</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Interface for IPFIX Type Bridges.</p>
<p>A Type Bridge handles export and collection of a <a class="el" href="classblockmon_1_1Msg.html">Msg</a> type or a set of related <a class="el" href="classblockmon_1_1Msg.html">Msg</a> types via the libfc IPFIX random-access (record) interface. Implement a bridge by implementing the <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#af54aff08f9c866d41c0d628a2c8ea377">canExport()</a>, <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a59dbb6e00423060596aec3b11ec3333b">prepareExporter()</a>, <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a4bebc40d6ac5092eed5febe348bb5515">exportMsg()</a>, <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a9da419480cc22135a46b0df3eea7d1b8">prepareCollector()</a>, and receiveRecord() (from <a class="el" href="classIPFIX_1_1RecordReceiver.html">IPFIX::RecordReceiver</a>) methods.</p>
<h1><a class="anchor" id="HOW"></a>
TO IMPORT/EXPORT YOUR MSG VIA IPFIX</h1>
<p>So you've written a <a class="el" href="classblockmon_1_1Msg.html">Msg</a> type and you want to import or export it via IPFIX, hm? OK, here are step-by-step instructions on how to get this to work.</p>
<p>Your <a class="el" href="classblockmon_1_1Msg.html">Msg</a> will likely contain a number of data members that you wish to import or export. For illustration purposes, we will assume that they are called "sourceIPv4Address", "payloadBuffer", and "domainName", and that they have the respective C++ types uint32_t, uint8_t*, and std::string. In other words:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMsg : <span class="keyword">public</span> Msg {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  uint32_t sourceIpv4Address;</div>
<div class="line">  uint8_t* payloadBuffer;</div>
<div class="line">  <span class="keywordtype">size_t</span> buffer_size;</div>
<div class="line">  std::string domainName;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyMsg(uint32 sourceIPv4Address,</div>
<div class="line">        uint8_t* payloadBuffer, <span class="keywordtype">size_t</span> buffer_size,</div>
<div class="line">        std::string&amp;  domainName);</div>
<div class="line"></div>
<div class="line">  uint32_t getSourceIPv4Address() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keyword">const</span> uint8_t* getPayloadBuffer() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">size_t</span> getPayloadBufferSize() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; getDomainName() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> setSourceIPv4Address(uint32_t);</div>
<div class="line">  <span class="keywordtype">void</span> setPayloadBuffer(<span class="keyword">const</span> uint8_t*, <span class="keywordtype">size_t</span>);</div>
<div class="line">  <span class="keywordtype">void</span> setDomainName(<span class="keyword">const</span> std::string&amp;);</div>
<div class="line"></div>
<div class="line">  ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>For import and export, you need a data structure that bridges between your implementation and IPFIX. You need an IPFIX type bridge. The first order of the day is therefore to write a skeleton for your bridge:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _IPFIXMYBRIDGE_H_</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#  define _IPFIXMYBRIDGE_H_</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#  include &quot;<a class="code" href="IPFIXTypeBridge_8hpp.html">IPFIXTypeBridge.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#  include &quot;<a class="code" href="IPFIXTypeRegistry_8hpp.html">IPFIXTypeRegistry.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#  include &lt;<a class="code" href="MatchTemplate_8h.html">MatchTemplate.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#  include &lt;<a class="code" href="InfoElement_8h.html">InfoElement.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>blockmon {</div>
<div class="line">  <span class="keyword">class </span>IPFIXMyBridge : <span class="keyword">public</span> IPFIXTypeBridge {</div>
<div class="line">    <a class="code" href="classIPFIX_1_1MatchTemplate.html">IPFIX::MatchTemplate</a> m_my_mtmpl;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    IPFIXMyBridge();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#a59dbb6e00423060596aec3b11ec3333b">prepareExporter</a>(<a class="code" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a>&amp; e) {</div>
<div class="line">      <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#a9778a95677eb46271dd1a5acf5095c4e">defaultPrepareExporter</a>(e);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#af54aff08f9c866d41c0d628a2c8ea377">canExport</a> (std::shared_ptr&lt;const Msg&gt;&amp; m);</div>
<div class="line">      </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#a4bebc40d6ac5092eed5febe348bb5515">exportMsg</a>(std::shared_ptr&lt;const Msg&gt;&amp; m, <a class="code" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a>&amp; e);</div>
<div class="line">      </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#a9da419480cc22135a46b0df3eea7d1b8">prepareCollector</a>(<a class="code" href="classIPFIX_1_1Collector.html">IPFIX::Collector</a>&amp; c, OutGate&amp; g) {</div>
<div class="line">      <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#a6039d979ceae39a3342c6172df220d5a">defaultPrepareCollector</a>(c, g);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> receiveRecord();</div>
<div class="line">  };</div>
<div class="line">} <span class="comment">// namespace blockmon</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // _IPFIXMYBRIDGE_H_</span></div>
</div><!-- fragment --><p>Put that in ipfix/IPFIXMyBridge.hpp. Now it's time to implement these member functions. So open up your editor on ipfix/IPFIXMyBridge.cpp. and start with this skeleton:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;IPFIXMyBridge.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;MyMsg.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>blockmon {</div>
<div class="line">} <span class="comment">// namespace blockmon</span></div>
</div><!-- fragment --><p>First, we tackle the constructor. The constructor must do three things: (1) initialise the base class, <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html">IPFIXTypeBridge</a>, (2) initialise member variables, and (3) find (and possibly install) the correct Information Elements in the Information Model.</p>
<p>The base class is initialised by passing the name of the <a class="el" href="classblockmon_1_1Msg.html">Msg</a> type to the base class. The only member variable in the skeleton is m_my_mtmpl, which needs no initialisation (the default constructor is called by, erm, default). That leaves the Information Elements (IEs).</p>
<p>If the IEs are already present in the information model (for example if the IE name is "sourceIPv4Address" and the InfoModel::instance() has been initialised with defaultIPFIX()), it is enough to give the name; otherwise an IE specification must be given. Luckily that is pretty easy to do. In our example, we have "sourceIPv4Address", which is already known, and "payloadBuffer", and "domainName", which are not. So your constructor could look like this:</p>
<div class="fragment"><div class="line">IPFIXMyBridge::IPFIXMyBridge()</div>
<div class="line">    : IPFIXTypeBridge(<span class="stringliteral">&quot;my&quot;</span>) {</div>
<div class="line">  declareIEVec(<span class="stringliteral">&quot;sourceIPv4Address&quot;</span>,</div>
<div class="line">               <span class="stringliteral">&quot;payloadBuffer(35501/101)&lt;octetArray&gt;[v]&quot;</span>,</div>
<div class="line">               <span class="stringliteral">&quot;domainName(35501/103)&lt;octetArray&gt;[v]&quot;</span>,</div>
<div class="line">               (<span class="keyword">const</span> <span class="keywordtype">char</span>*)0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>(This is not a tutorial on how to write IE specs. If you don't know what these specifications above mean, please consult draft-ietf-ipfix-ie-doctors)</p>
<p>Next we need to tell the exporter if we can export a certain <a class="el" href="classblockmon_1_1Msg.html">Msg</a>. In this case, that's easy, since we can only export MyMsg's:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#af54aff08f9c866d41c0d628a2c8ea377">IPFIXMyBridge::canExport</a> (std::shared_ptr&lt;const Msg&gt;&amp; m) {</div>
<div class="line">  <span class="keywordflow">return</span> m-&gt;type() == MSG_ID(MyMsg);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we need to export the <a class="el" href="classblockmon_1_1Msg.html">Msg</a> to IPFIX. That's pretty easy too, we just tell the <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html">IPFIXTypeBridge</a> which IE has what value:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classblockmon_1_1IPFIXTypeBridge.html#a4bebc40d6ac5092eed5febe348bb5515">IPFIXMyBridge::exportMsg</a>(std::shared_ptr&lt;const Msg&gt;&amp; m,</div>
<div class="line">                              <a class="code" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a>&amp; e) {</div>
<div class="line">   std::shared_ptr&lt;const MyMsg&gt; msg</div>
<div class="line">     = std::dynamic_pointer_cast&lt;<span class="keyword">const</span> MyMsg&gt;(m);</div>
<div class="line"></div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#add010496363354ad8ab0b5cd9be3af64">setTemplate</a>(m_tid);</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#af0b448fbd9e54151c55e4c29069fa2fe">beginRecord</a>();</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#abf568cd170d345f702792309845ee1b9">reserveVarlen</a>(m_ievec[1], msg-&gt;getPayloadBufferSize());</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#abf568cd170d345f702792309845ee1b9">reserveVarlen</a>(m_ievec[2], msg-&gt;getDomainName().length());</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#a388bda9d3be1c624b3f78377bfc99008">commitVarlen</a>();</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#a53529369c10b92ed7706506e32820879">putValue</a>(m_ievec[0], static_cast&lt;uint32_t&gt;(msg-&gt;getSourceIPv4Address());</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#a53529369c10b92ed7706506e32820879">putValue</a>(m_ievec[1], msg-&gt;getPayloadBuffer(),</div>
<div class="line">              msg-&gt;getPayloadBufferSize())</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#a53529369c10b92ed7706506e32820879">putValue</a>(m_ievec[2], msg-&gt;getDomainName());</div>
<div class="line">   e.<a class="code" href="classIPFIX_1_1Exporter.html#a1f8d07994e0184d30d7c5d0662d826ef">exportRecord</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>All variable-length Information Elements must have their values reserved and committed before any values are put in the record, so that the exporter knows the offset to each information element and can flush any buffers beforehand that would be overflowed by the export.</p>
<p>Now, let's go into the opposite direction, importing a value from IPFIX:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> IPFIXMyBridge::receiveRecord() {</div>
<div class="line">  uint32_t sourceIPv4Address;</div>
<div class="line">  uint32_t bufferSize;</div>
<div class="line">  uint8_t* buffer;</div>
<div class="line">  std::string domainName;</div>
<div class="line"></div>
<div class="line">  assert(<a class="code" href="classIPFIX_1_1RecordReceiver.html#af94751648789be240faef16839b33d92">getValue</a>(m_ievec[0], sourceIPv4Address));</div>
<div class="line">  assert(<a class="code" href="classIPFIX_1_1RecordReceiver.html#af94751648789be240faef16839b33d92">getValue</a>(m_ievec[1], bufferSize));</div>
<div class="line"></div>
<div class="line">  buffer = <span class="keyword">new</span> uint8_t[bufferSize];</div>
<div class="line"></div>
<div class="line">  assert(<a class="code" href="classIPFIX_1_1RecordReceiver.html#af94751648789be240faef16839b33d92">getValue</a>(m_ievec[2], buffer, bufferSize));</div>
<div class="line">  assert(<a class="code" href="classIPFIX_1_1RecordReceiver.html#af94751648789be240faef16839b33d92">getValue</a>(m_ievec[3], domainName);</div>
<div class="line"></div>
<div class="line">  std::shared_ptr&lt;MyMsg&gt; m =</div>
<div class="line">    std::make_shared&lt;MyMsg&gt;(sourceIPv4Address,</div>
<div class="line">                            buffer, bufferSize,</div>
<div class="line">                            domainName);</div>
<div class="line">  sendMsg(std::move(m));</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a class="el" href="classIPFIX_1_1RecordReceiver.html#af94751648789be240faef16839b33d92">getValue()</a> function returns true or false, depending on whether the IE was found in the current IPFIX record. You can use this to extract optional fields from an IPFIX record.</p>
<p>And that's it! See, it wasn't so bad, was it? </p>

<p>Definition at line <a class="el" href="IPFIXTypeBridge_8hpp_source.html#l00259">259</a> of file <a class="el" href="IPFIXTypeBridge_8hpp_source.html">IPFIXTypeBridge.hpp</a>.</p>
</div><h2>Member Function Documentation</h2>
<a class="anchor" id="af54aff08f9c866d41c0d628a2c8ea377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockmon::IPFIXTypeBridge::canExport </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classblockmon_1_1Msg.html">Msg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Examine a Message to see if it can be exported using this Bridge. This method generally examines the message's msg_type() to determine this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>message to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message can be exported by this bridge </dd></dl>

<p>Implemented in <a class="el" href="classblockmon_1_1IPFIXFlowBridge.html#a33b53ac111cebc315e837352de84cd43">blockmon::IPFIXFlowBridge</a>, <a class="el" href="classblockmon_1_1IPFIXObservationBridge.html#a879f507144b54b654b29cd63283f82d1">blockmon::IPFIXObservationBridge</a>, and <a class="el" href="classblockmon_1_1SCDemoFlowBridge.html#a81080bf093f324dd79590d3474cbe7de">blockmon::SCDemoFlowBridge</a>.</p>

</div>
</div>
<a class="anchor" id="a955cfbd55b9184ebe83a67c58cadab7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blockmon::IPFIXTypeBridge::declareIEVec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>spec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variadic function taking a list of partial or full IE specifiers. Information elements not already in the model will be added (assuming a full specifier is present). The resulting cached IE pointers can be accessed through m_ievec. Should be called in derived member constructors if used, and the return value checked.</p>
<dl class="section return"><dt>Returns</dt><dd>false if an IE lookup or model addition failed </dd></dl>

<p>Definition at line <a class="el" href="IPFIXTypeBridge_8cpp_source.html#l00068">68</a> of file <a class="el" href="IPFIXTypeBridge_8cpp_source.html">IPFIXTypeBridge.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb083d32c7747a3f69ab593e3f23857e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blockmon::IPFIXTypeBridge::declareIEVec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classIPFIX_1_1InfoElement.html">IPFIX::InfoElement</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>spec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variadic function taking a list of partial or full IE specifiers. Information elements not already in the model will be added (assuming a full specifier is present). Caches IE pointers in the supplied vector; used when a bridge needs multiple IE vectors (i.e., for multiple templates). Should be called in derived member constructors if used, and the return value checked.</p>
<dl class="section return"><dt>Returns</dt><dd>false if an IE lookup or model addition failed </dd></dl>

<p>Definition at line <a class="el" href="IPFIXTypeBridge_8cpp_source.html#l00057">57</a> of file <a class="el" href="IPFIXTypeBridge_8cpp_source.html">IPFIXTypeBridge.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6039d979ceae39a3342c6172df220d5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blockmon::IPFIXTypeBridge::defaultPrepareCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPFIX_1_1Collector.html">IPFIX::Collector</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblockmon_1_1OutGate.html">OutGate</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default implementation of collector preperation, registers the bridge as receiver for a match template, stored in m_mtmpl, using all the InfoElements in m_ievec (declared by declareIEVec() in the constructor). Call from <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a9da419480cc22135a46b0df3eea7d1b8">prepareCollector()</a> unless the bridge requires alternation (multiple match templates) or other custom preparation. Bridges supporting optional values can use the three-argument form of <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a6039d979ceae39a3342c6172df220d5a">defaultPrepareCollector()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>collector to prepare </td></tr>
    <tr><td class="paramname">g</td><td>gate through which messages will be sent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IPFIXTypeBridge_8cpp_source.html#l00088">88</a> of file <a class="el" href="IPFIXTypeBridge_8cpp_source.html">IPFIXTypeBridge.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf3aeb67e51ab3f63cc7b23d6106860a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blockmon::IPFIXTypeBridge::defaultPrepareCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPFIX_1_1Collector.html">IPFIX::Collector</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblockmon_1_1OutGate.html">OutGate</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>match_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default implementation of collector preperation, registers the bridge as receiver for a match template, stored in m_mtmpl, using the InfoElements in m_ievec listed in match_indices. Call from <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a9da419480cc22135a46b0df3eea7d1b8">prepareCollector()</a> unless the bridge requires alternation (multiple match templates) or other custom preparation. Bridges supporting optional values can use the three-argument form of <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a6039d979ceae39a3342c6172df220d5a">defaultPrepareCollector()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>collector to prepare </td></tr>
    <tr><td class="paramname">g</td><td>gate through which messages will be sent </td></tr>
    <tr><td class="paramname">match_indices</td><td>indices into m_ievec which must be present in received templates </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IPFIXTypeBridge_8cpp_source.html#l00100">100</a> of file <a class="el" href="IPFIXTypeBridge_8cpp_source.html">IPFIXTypeBridge.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9778a95677eb46271dd1a5acf5095c4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blockmon::IPFIXTypeBridge::defaultPrepareExporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default implementation of exporter preparation, creates a single template using all the InfoElements in m_ievec (declared by declareIEVec in the constructor) in order, and stores the ID of this template in m_tid. Call from prepareExporter unless the bridge requires multiple templates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>exporter to prepare </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="IPFIXTypeBridge_8cpp_source.html#l00076">76</a> of file <a class="el" href="IPFIXTypeBridge_8cpp_source.html">IPFIXTypeBridge.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bebc40d6ac5092eed5febe348bb5515"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blockmon::IPFIXTypeBridge::exportMsg </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classblockmon_1_1Msg.html">Msg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export a message to a given exporter. This exporter will already have been prepared by this bridge using <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a59dbb6e00423060596aec3b11ec3333b">prepareExporter()</a>, and the Message already checked using <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#af54aff08f9c866d41c0d628a2c8ea377">canExport()</a>. Can use either the exportStruct() or exportRecord() interfaces provided by Exporter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>message to export </td></tr>
    <tr><td class="paramname">e</td><td>exporter to use </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classblockmon_1_1IPFIXFlowBridge.html#a64306680b07cf7ebf55b307e466434a3">blockmon::IPFIXFlowBridge</a>, <a class="el" href="classblockmon_1_1SCDemoFlowBridge.html#a26aac90a907acd3b6259a613d91fd9d4">blockmon::SCDemoFlowBridge</a>, and <a class="el" href="classblockmon_1_1IPFIXObservationBridge.html#a1a17c9ee3e3e24235dd3e1b11780913b">blockmon::IPFIXObservationBridge</a>.</p>

</div>
</div>
<a class="anchor" id="a9da419480cc22135a46b0df3eea7d1b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blockmon::IPFIXTypeBridge::prepareCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPFIX_1_1Collector.html">IPFIX::Collector</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblockmon_1_1OutGate.html">OutGate</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare a collector to receive records using this bridge, by registering the bridge as a reciever for a minimal match template and caching the gate through which <a class="el" href="classblockmon_1_1Msg.html">blockmon::Msg</a> instances will be sent.</p>
<p>Must be implemented by subclasses, which can generally just delegate this to <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a6039d979ceae39a3342c6172df220d5a">defaultPrepareCollector()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>collector to prepare </td></tr>
    <tr><td class="paramname">g</td><td>gate through which messages will be sent </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classblockmon_1_1IPFIXFlowBridge.html#af8b84fa9d04133b0c4aba8ed4600058a">blockmon::IPFIXFlowBridge</a>, <a class="el" href="classblockmon_1_1SCDemoFlowBridge.html#a66ff121a2ccf645886ec5024906840ce">blockmon::SCDemoFlowBridge</a>, and <a class="el" href="classblockmon_1_1IPFIXObservationBridge.html#aab95ba70074f9a5847c8d0c38488dc66">blockmon::IPFIXObservationBridge</a>.</p>

</div>
</div>
<a class="anchor" id="a59dbb6e00423060596aec3b11ec3333b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blockmon::IPFIXTypeBridge::prepareExporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIPFIX_1_1Exporter.html">IPFIX::Exporter</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare an exporter to export records from this bridge, by creating and registering WireTemplates for export.</p>
<p>Must be implemented by subclasses, which can generally just delegate this to <a class="el" href="classblockmon_1_1IPFIXTypeBridge.html#a9778a95677eb46271dd1a5acf5095c4e">defaultPrepareExporter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>exporter to prepare </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classblockmon_1_1SCDemoFlowBridge.html#ad417dc8d265534b4cbc7bba26847f93d">blockmon::SCDemoFlowBridge</a>, <a class="el" href="classblockmon_1_1IPFIXFlowBridge.html#acd76e32c8a3c10002bfb49f37db887ec">blockmon::IPFIXFlowBridge</a>, and <a class="el" href="classblockmon_1_1IPFIXObservationBridge.html#ae518ab91b6c80749259ea2b89bc8e60b">blockmon::IPFIXObservationBridge</a>.</p>

</div>
</div>
<a class="anchor" id="ace3a14ecf9d038012ce312882f88301e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; blockmon::IPFIXTypeBridge::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the typename by which this bridge is known; this matches the datatype name attribute in parameters for the <a class="el" href="classblockmon_1_1IPFIXExporter.html">IPFIXExporter</a> and <a class="el" href="classblockmon_1_1IPFIXSource.html">IPFIXSource</a> blocks, and is used by default implementations as the template name for the template ID registry. The type name is set in the constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>type name. </dd></dl>

<p>Definition at line <a class="el" href="IPFIXTypeBridge_8hpp_source.html#l00420">420</a> of file <a class="el" href="IPFIXTypeBridge_8hpp_source.html">IPFIXTypeBridge.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/santiago/src/blockmon-compile-a-la-upstream/blockmon-0.827872f/ipfix/<a class="el" href="IPFIXTypeBridge_8hpp_source.html">IPFIXTypeBridge.hpp</a></li>
<li>/home/santiago/src/blockmon-compile-a-la-upstream/blockmon-0.827872f/ipfix/<a class="el" href="IPFIXTypeBridge_8cpp_source.html">IPFIXTypeBridge.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 2 2013 17:48:35 for blockmon by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
